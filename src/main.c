/*
******************************************************************************
File:     main.c
Info:     Generated by Atollic TrueSTUDIO(R) 9.0.0   2020-02-01

The MIT License (MIT)
Copyright (c) 2018 STMicroelectronics

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

******************************************************************************
*/

/* Includes */
#include <stddef.h>
#include "BoardSupport.h"
#include "LinkedList.h"
/* Kernel includes. */
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "timers.h"
#include "semphr.h"

/* Private typedef */
/* Private define  */
#define mainQUEUE_LENGTH 10
#define mainQUEUE_RECEIVE_TASK_PRIORITY		( tskIDLE_PRIORITY + 2 )
#define	mainQUEUE_SEND_TASK_PRIORITY		( tskIDLE_PRIORITY + 1 )

#define mainQUEUE_SEND_FREQUENCY_MS			( 100 / portTICK_PERIOD_MS )


/* Private macro */
/* Private variables */
extern uint32_t BEEP_TICK_LENGTH;
extern uint32_t SPACE_TICK_LENGTH;

uint32_t startTick = 0;
uint32_t ticks = 0;
static QueueHandle_t xQueue = NULL, MessageQueue = NULL;
SemaphoreHandle_t  xSemaphorePolling = NULL, xSemaphoreISR = NULL;
static TimerHandle_t xLEDTimer = NULL;

TaskHandle_t  RecordButtonPressesTask = NULL;


uint8_t pressed = 0;
struct ButtonPress{
	uint32_t time;
	uint8_t buttonState;
};
/* Private function prototypes */
//task function(s)
static void PollingTask( void *pvParameters );
static void RecordButtonPresses( void *pvParameters );
//timer callback function(s)
static void TranslateMorseCode( TimerHandle_t xTimer );



/* Private functions */
static void TranslateMorseCode( TimerHandle_t xTimer )
{
	//stop recorButtonPresses task(can i use semaphore, i think beter to do this since is activated by a timer, block time must be zero if using semaphore)
	vTaskSuspend(RecordButtonPressesTask);
	xSemaphoreTake(xSemaphoreISR, 0);//try to clear the semaphore for the ISR
	xSemaphoreTake(xSemaphorePolling, 0);//try to clear the semaphore for the ISR
	char* c = TranslateSelf();


	//MessageQueue
	//figure out what to do with the message

	//start recorButtonPresses task
	vTaskResume(RecordButtonPressesTask);
	xSemaphoreGive(xSemaphoreISR);//try to clear the semaphore for the ISR
}

static void RecordButtonPresses( void *pvParameters )
{
	struct ButtonPress button;
	for(;;)
	{
		//wait for something to be in the queue for portMAX_DELAY
		xQueueReceive( xQueue, &button, portMAX_DELAY );
		ButtonPress(button.time,button.buttonState);
		//queue message(in an other queue)
		//add semaphore to notify other task
		//other task will stop the polling task and start it once finished
		//the task will display back the message(in the case im thinking it will just morse code back the message to confirm, might want to do this a character a time)
	}
}

static void PollingTask( void *pvParameters )
{
	TickType_t startTicks = 0;
	struct ButtonPress button;
	for(;;)
	{
		//wait for semaphore from interrupt
		if( xSemaphorePolling != NULL )
		{
			/* See if we can obtain the semaphore.  If the semaphore is not
			available wait 10 ticks(can maybe increase this to max so it waits forever) to see if it becomes free. */
			if( xSemaphoreTake( xSemaphorePolling, ( TickType_t ) 10 ) == pdTRUE ){
				xTimerStop(xLEDTimer, 0);

				TickType_t endTicks, difference;

				//diffrence from button release
				difference = xTaskGetTickCount() - startTicks;

				//add to queue
				button.buttonState = 0;//time from when it was released
				button.time = difference;
				xQueueSend( xQueue, &button, 0 );

				GPIOC->BSRR |= (uint32_t)GPIO_PIN_9;

				startTicks = xTaskGetTickCount();

				/* Buton release polling */
				while(GPIO_ReadInputDataBit(GPIOA, GPIO_PIN_0) != Bit_RESET){
					//wait for the button to be unpressed(or maybe can connect same button to a interrupt that can release and it will wait for that semaphore?)

					//no operation(used to keep empty while loop working)
					asm("nop");
				}

				GPIOC->BSRR = (uint32_t)GPIO_PIN_9 << 16U;

				endTicks = xTaskGetTickCount();
				difference = endTicks - startTicks;//button held time
				//add to queue(button released, was held)
				button.buttonState = 1;//time it was held for
				button.time = difference;
				xQueueSend( xQueue, &button, 1);

				//start Timer, to call the translate task
				xTimerReset(xLEDTimer, 0);
				xTimerStart(xLEDTimer, 0);

				//block so ISR semaphore in ISR cannot be triggerd for a period of time
				vTaskDelayUntil( &endTicks, mainQUEUE_SEND_FREQUENCY_MS );


				//release semaphoreISR (giving the semaphore so ISR can happen and give this task the semaphore it needs)
	            xSemaphoreGive( xSemaphoreISR );
	            pressed = 0;
				startTicks = xTaskGetTickCount();
			}
		}
	}
}

void EXTI0_IRQHandler(void)
{
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;

    if (EXTI_GetITStatus(EXTI_Line0) != RESET) {
    	if(xSemaphoreTakeFromISR( xSemaphoreISR, &xHigherPriorityTaskWoken ) == pdTRUE){
	        xSemaphoreGiveFromISR( xSemaphorePolling, &xHigherPriorityTaskWoken );
    	}
    	/* Clear interrupt flag */
        EXTI_ClearITPendingBit(EXTI_Line0);
    }

	portEND_SWITCHING_ISR( xHigherPriorityTaskWoken );
}
/**
**===========================================================================
**
**  Abstract: main program
**
**===========================================================================
*/
int main(void)
{
  int i = 0;

  /**
  *  IMPORTANT NOTE!
  *  The symbol VECT_TAB_SRAM needs to be defined when building the project
  *  if code has been located to RAM and interrupts are used. 
  *  Otherwise the interrupt table located in flash will be used.
  *  See also the <system_*.c> file and how the SystemInit() function updates 
  *  SCB->VTOR register.  
  *  E.g.  SCB->VTOR = 0x20000000;  
  */


  /* TODO - Add your application code here */
  /* GPIO Ports Clock Enable */
  //give priority for preemption
  NVIC_PriorityGroupConfig( NVIC_PriorityGroup_4 );


  /* Enable timer for ports */
  RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;//port C
  initGPIO(GPIOC, GPIO_PIN_9, 9, GPIO_Speed_50MHz);
  initGPIO(GPIOC, GPIO_PIN_8, 8, GPIO_Speed_50MHz);

  /* Enable the BUTTON Clock */
  RCC->APB2ENR |= RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO;//port A

  /* Configure Button pin as input floating */
  initGPIO(GPIOA, GPIO_Pin_0, 0, GPIO_Mode_IN_FLOATING);
  initEXTI(GPIO_PortSourceGPIOA, GPIO_PinSource0, EXTI_Line0, EXTI_Mode_Interrupt, EXTI_Trigger_Rising, EXTI0_IRQn);

  /* Create the timer(s) */
  xLEDTimer = xTimerCreate( 	"LEDTimer", 				/* A text name, purely to help debugging. */
							((SPACE_TICK_LENGTH * 10) / portTICK_PERIOD_MS ),/* The timer period, in this case (SPACE_TICK_LENGTH * 10) ms. */
							pdFALSE,					/* This is a one-shot timer, so xAutoReload is set to pdFALSE. */
							( void * ) 0,				/* The ID is not used, so can be set to anything. */
							TranslateMorseCode			/* The callback function that switches the LED off. */
						);

  /* Create the queue. */
  xQueue = xQueueCreate( mainQUEUE_LENGTH, sizeof( struct ButtonPress ) );
  MessageQueue = xQueueCreate( mainQUEUE_LENGTH, sizeof( char* ) );

  xSemaphorePolling = xSemaphoreCreateBinary();
  xSemaphoreISR = xSemaphoreCreateBinary();
  xSemaphoreGive(xSemaphoreISR);

  /* create the task(s) */
  xTaskCreate( PollingTask, "ButtonPolling", configMINIMAL_STACK_SIZE, NULL, mainQUEUE_SEND_TASK_PRIORITY, NULL );
  xTaskCreate( RecordButtonPresses, "RecordBP", configMINIMAL_STACK_SIZE, NULL, mainQUEUE_RECEIVE_TASK_PRIORITY, &RecordButtonPressesTask );

  /*start tasks*/
  vTaskStartScheduler();

  /* Infinite loop (should never hit) */
  while (1)
  {
  }
}

/*
 * Minimal __assert_func used by the assert() macro
 * */
void __assert_func(const char *file, int line, const char *func, const char *failedexpr)
{
  while(1)
  {}
}

/*
 * Minimal __assert() uses __assert__func()
 * */
void __assert(const char *file, int line, const char *failedexpr)
{
   __assert_func (file, line, NULL, failedexpr);
}

/*-----------------------------------------------------------*/

void vApplicationMallocFailedHook( void )
{
	/* Called if a call to pvPortMalloc() fails because there is insufficient
	free memory available in the FreeRTOS heap.  pvPortMalloc() is called
	internally by FreeRTOS API functions that create tasks, queues, software
	timers, and semaphores.  The size of the FreeRTOS heap is set by the
	configTOTAL_HEAP_SIZE configuration constant in FreeRTOSConfig.h. */
	for( ;; );
}
/*-----------------------------------------------------------*/

void vApplicationStackOverflowHook( TaskHandle_t pxTask, char *pcTaskName )
{
	( void ) pcTaskName;
	( void ) pxTask;

	/* Run time stack overflow checking is performed if
	configconfigCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
	function is called if a stack overflow is detected. */
	for( ;; );
}
/*-----------------------------------------------------------*/

void vApplicationIdleHook( void )
{
volatile size_t xFreeStackSpace;

	/* This function is called on each cycle of the idle task.  In this case it
	does nothing useful, other than report the amout of FreeRTOS heap that
	remains unallocated. */
	xFreeStackSpace = xPortGetFreeHeapSize();

	if( xFreeStackSpace > 100 )
	{
		/* By now, the kernel has allocated everything it is going to, so
		if there is a lot of heap remaining unallocated then
		the value of configTOTAL_HEAP_SIZE in FreeRTOSConfig.h can be
		reduced accordingly. */
	}
}
