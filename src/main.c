/*
******************************************************************************
File:     main.c
Info:     Generated by Atollic TrueSTUDIO(R) 9.0.0   2020-02-01

The MIT License (MIT)
Copyright (c) 2018 STMicroelectronics

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

******************************************************************************
*/

/* Includes */
#include <stddef.h>
#include "BoardSupport.h"
#include "LinkedList.h"
/* Kernel includes. */
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "timers.h"
#include "semphr.h"

/* Private typedef */
/* Private define  */
#define mainQUEUE_LENGTH 1
#define mainQUEUE_RECEIVE_TASK_PRIORITY		( tskIDLE_PRIORITY + 2 )
#define	mainQUEUE_SEND_TASK_PRIORITY		( tskIDLE_PRIORITY + 1 )

#define mainQUEUE_SEND_FREQUENCY_MS			( 100 / portTICK_PERIOD_MS )


/* Private macro */
/* Private variables */
uint32_t startTick = 0;
uint32_t ticks = 0;
static QueueHandle_t xQueue = NULL;
SemaphoreHandle_t  xSemaphore = NULL;
uint8_t pressed = 0;
/* Private function prototypes */
static void PollingTask( void *pvParameters );
//void RecordButtonPresses();

/* Private functions */
static void PollingTask( void *pvParameters )
{
	for(;;)
	{
		//wait for semaphore from interrupt
		if( xSemaphore != NULL )
		{
			/* See if we can obtain the semaphore.  If the semaphore is not
			available wait 10 ticks(can maybe increase this to max so it waits forever) to see if it becomes free. */
			if( xSemaphoreTake( xSemaphore, ( TickType_t ) 10 ) == pdTRUE ){

				/*button pressed*/

				TickType_t xStart, xEnd;
				xTaskGetTickCount();

				pressed = 1;

				//TODO- add to queue(button press)
				GPIOC->BSRR |= (uint32_t)GPIO_PIN_9;

				/* Buton release polling */
				while(GPIO_ReadInputDataBit(GPIOA, GPIO_PIN_0) != Bit_RESET){
					//wait for the button to be unpressed(or maybe can connect same button to a interrupt that can release and it will wait for that semaphore?)

					//no operation(used to keep empty while loop working)
					asm("nop");
				}

				//TODO- add to queue(button released)
				GPIOC->BSRR = (uint32_t)GPIO_PIN_9 << 16U;

				TickType_t xNextWakeTime;

				/* Initialise xNextWakeTime - this only needs to be done once. */
				xNextWakeTime = xTaskGetTickCount();

				//block so ISR semaphore in ISR cannot be triggerd for a period of time
				vTaskDelayUntil( &xNextWakeTime, mainQUEUE_SEND_FREQUENCY_MS );

				//release semaphore (giving the semaphore back so other tasks can take it)
	            //xSemaphoreGive( xSemaphore );
	            pressed = 0;
			}
		}
	}
}

void EXTI0_IRQHandler(void)
{
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;

    if (EXTI_GetITStatus(EXTI_Line0) != RESET) {
    	if(pressed == 0){
			uint32_t dif = ticks - startTick;
			//if(dif > 200){
	        xSemaphoreGiveFromISR( xSemaphore, &xHigherPriorityTaskWoken );
			//}
    	}
    	/* Clear interrupt flag */
        EXTI_ClearITPendingBit(EXTI_Line0);
    }

	portEND_SWITCHING_ISR( xHigherPriorityTaskWoken );
}
/**
**===========================================================================
**
**  Abstract: main program
**
**===========================================================================
*/
int main(void)
{
  int i = 0;

  /**
  *  IMPORTANT NOTE!
  *  The symbol VECT_TAB_SRAM needs to be defined when building the project
  *  if code has been located to RAM and interrupts are used. 
  *  Otherwise the interrupt table located in flash will be used.
  *  See also the <system_*.c> file and how the SystemInit() function updates 
  *  SCB->VTOR register.  
  *  E.g.  SCB->VTOR = 0x20000000;  
  */


  /* TODO - Add your application code here */
  /* GPIO Ports Clock Enable */
	NVIC_PriorityGroupConfig( NVIC_PriorityGroup_4 );


  /* Enable timer for ports */
  RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;//port C
  initGPIO(GPIOC, GPIO_PIN_9, 9, GPIO_Speed_50MHz);
  initGPIO(GPIOC, GPIO_PIN_8, 8, GPIO_Speed_50MHz);

  /* Enable the BUTTON Clock */
  RCC->APB2ENR |= RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO;//port A

  /* Configure Button pin as input floating */
  initGPIO(GPIOA, GPIO_Pin_0, 0, GPIO_Mode_IN_FLOATING);
  initEXTI(GPIO_PortSourceGPIOA, GPIO_PinSource0, EXTI_Line0, EXTI_Mode_Interrupt, EXTI_Trigger_Rising, EXTI0_IRQn);


  /* Create the queue. */
  xQueue = xQueueCreate( mainQUEUE_LENGTH, sizeof( unsigned long ) );
  xSemaphore = xSemaphoreCreateBinary();

  /* create the task(s) */
  xTaskCreate( PollingTask, "Rx", configMINIMAL_STACK_SIZE, NULL, mainQUEUE_RECEIVE_TASK_PRIORITY, NULL );

  /*start tasks*/
  vTaskStartScheduler();

  /* Infinite loop (should never hit) */
  while (1)
  {
  }
}

/*
 * Minimal __assert_func used by the assert() macro
 * */
void __assert_func(const char *file, int line, const char *func, const char *failedexpr)
{
  while(1)
  {}
}

/*
 * Minimal __assert() uses __assert__func()
 * */
void __assert(const char *file, int line, const char *failedexpr)
{
   __assert_func (file, line, NULL, failedexpr);
}

/*-----------------------------------------------------------*/

void vApplicationMallocFailedHook( void )
{
	/* Called if a call to pvPortMalloc() fails because there is insufficient
	free memory available in the FreeRTOS heap.  pvPortMalloc() is called
	internally by FreeRTOS API functions that create tasks, queues, software
	timers, and semaphores.  The size of the FreeRTOS heap is set by the
	configTOTAL_HEAP_SIZE configuration constant in FreeRTOSConfig.h. */
	for( ;; );
}
/*-----------------------------------------------------------*/

void vApplicationStackOverflowHook( TaskHandle_t pxTask, char *pcTaskName )
{
	( void ) pcTaskName;
	( void ) pxTask;

	/* Run time stack overflow checking is performed if
	configconfigCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
	function is called if a stack overflow is detected. */
	for( ;; );
}
/*-----------------------------------------------------------*/

void vApplicationIdleHook( void )
{
volatile size_t xFreeStackSpace;

	/* This function is called on each cycle of the idle task.  In this case it
	does nothing useful, other than report the amout of FreeRTOS heap that
	remains unallocated. */
	xFreeStackSpace = xPortGetFreeHeapSize();

	if( xFreeStackSpace > 100 )
	{
		/* By now, the kernel has allocated everything it is going to, so
		if there is a lot of heap remaining unallocated then
		the value of configTOTAL_HEAP_SIZE in FreeRTOSConfig.h can be
		reduced accordingly. */
	}
}
